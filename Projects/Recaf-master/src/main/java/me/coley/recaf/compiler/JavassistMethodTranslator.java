package me.coley.recaf.compiler;

import javassist.*;
import javassist.bytecode.*;
import me.coley.recaf.util.OpcodeUtil;
import org.objectweb.asm.tree.*;

import java.util.HashSet;
import java.util.Set;

/**
 * Allows translation of generated bytecode from Javassist by exposing each generated instruction in a visitor pattern.
 *
 * @author Matt
 */
public class JavassistMethodTranslator {
	private final Set<Integer> labelOffsets = new HashSet<>();

	/**
	 * Translates the given code depending on the implementation.
	 *
	 * @param clazz
	 * 		Owner type of code being written.
	 * @param code
	 * 		Code to translate.
	 *
	 * @throws CannotCompileException
	 * 		When the code cannot be compiled due to syntax or resolution errors.
	 * @throws BadBytecode
	 * 		When the code generated is malformed.
	 */
	public void visit(CtClass clazz, CodeAttribute code) throws CannotCompileException, BadBytecode {
		populateControlFlowTargets(code);
		iterateCode(clazz, code.iterator());
	}

	private void populateControlFlowTargets(CodeAttribute code) throws BadBytecode {
		labelOffsets.add(0);
		CodeIterator iterator  = code.iterator();
		while (iterator.hasNext())
			populateLabels(iterator);
		labelOffsets.add(code.getCodeLength());
	}

	private void iterateCode(CtClass clazz, CodeIterator iterator) throws CannotCompileException, BadBytecode {
		visitBranchDestination(0);
		while (iterator.hasNext())
			handleNextInsn(clazz, iterator);
		visitBranchDestination(iterator.getCodeLength());
	}

	private void populateLabels(CodeIterator iterator) throws BadBytecode {
		int pos = iterator.next();
		int c = iterator.byteAt(pos);
		int type;
		try {
			type = OpcodeUtil.opcodeToType(c);
		} catch (NullPointerException e) {
			throw new IllegalStateException("Unhandled op: " + c);
		}
		if (type == AbstractInsnNode.JUMP_INSN) {
			int offset = getJumpOffset(c, pos, iterator);
			labelOffsets.add(offset);
		}
	}

	private void handleNextInsn(CtClass clazz, CodeIterator iterator)
			throws CannotCompileException, BadBytecode {
		int pos = iterator.next();
		if (labelOffsets.contains(pos))
			visitBranchDestination(pos);
		int c = iterator.byteAt(pos);
		ConstPool cp = clazz.getClassFile().getConstPool();
		int type;
		try {
			type = OpcodeUtil.opcodeToType(c);
		} catch (NullPointerException e) {
			throw new IllegalStateException("Unhandled op: " + c);
		}
		switch (type) {
			case AbstractInsnNode.INSN:
				visitInsn(c);
				break;
			case AbstractInsnNode.INT_INSN: {
				int value;
				if (c == Opcode.BIPUSH || c == Opcode.NEWARRAY) {
					value = iterator.byteAt(pos + 1);
				} else if (c == Opcode.SIPUSH) {
					value = iterator.s16bitAt(pos + 1);
				} else {
					throw new BadBytecode("Unknown int insn: " + c);
				}
				visitInt(c, value);
				break;
			}
			case AbstractInsnNode.VAR_INSN: {
				int index;
				if (OpcodeUtil.deindexVarOp(c) != c) {
					index = OpcodeUtil.indexFromVarOp(c);
				} else {
					index = iterator.byteAt(pos + 1);
				}
				visitVar(c, index);
				break;
			}
			case AbstractInsnNode.TYPE_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				String name = Descriptor.toJvmName(cp.getClassInfo(index));
				visitType(c, name);
				break;
			}
			case AbstractInsnNode.FIELD_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				String owner = Descriptor.toJvmName(cp.getFieldrefClassName(index));
				String name = cp.getFieldrefName(index);
				String signature = cp.getFieldrefType(index);
				visitField(c, owner, name, signature);
				break;
			}
			case AbstractInsnNode.METHOD_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				int nameType;
				if (c == Opcode.INVOKEINTERFACE)
					nameType = cp.getInterfaceMethodrefNameAndType(index);
				else
					nameType = cp.getMethodrefNameAndType(index);
				String owner = Descriptor.toJvmName(cp.getMethodrefClassName(index));
				String name = cp.getUtf8Info(cp.getNameAndTypeName(nameType));
				String signature = cp.getUtf8Info(cp.getNameAndTypeDescriptor(nameType));
				visitMethod(c, owner, name, signature);
				break;
			}
			case AbstractInsnNode.IINC_INSN: {
				int index = iterator.byteAt(pos + 1);
				int incr = iterator.signedByteAt(pos + 2);
				visitIinc(c, index, incr);
				break;
			}
			case AbstractInsnNode.LDC_INSN: {
				int index;
				if (c == Opcode.LDC)
					index = iterator.byteAt(pos + 1);
				else
					index = iterator.u16bitAt(pos + 1);
				Object value = cp.getLdcValue(index);
				visitLdc(c, value);
				break;
			}
			case AbstractInsnNode.MULTIANEWARRAY_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				int dimensions = iterator.byteAt(pos + 3);
				String elementType = cp.getClassInfo(index);
				visitMultiANewArray(c, elementType, dimensions);
				break;
			}
			case AbstractInsnNode.INVOKE_DYNAMIC_INSN:
				// I don't think Javassist is even capable of outputting INDY
				throw new CannotCompileException("Invoke dynamic instructions not supported");
			case AbstractInsnNode.JUMP_INSN:
				int offset = getJumpOffset(c, pos, iterator);
				visitJump(c, offset);
				break;
			case AbstractInsnNode.LOOKUPSWITCH_INSN:
			case AbstractInsnNode.TABLESWITCH_INSN:
				throw new CannotCompileException("Control flow instructions not supported");
			default:
				throw new CannotCompileException("Unhandled instruction type for opcode: " + c);
		}
	}

	private int getJumpOffset(int c, int pos, CodeIterator iterator) {
		if (c == Opcode.GOTO_W)
			return pos + iterator.s32bitAt(pos + 1);
		else
			return pos + iterator.u16bitAt(pos + 1);
	}

	/// ================== Below are stubs for children to implement ================== ///

	/**
	 * Visit a control flow destination.
	 *
	 * @param offset
	 * 		Absolute offset in the method code for the destination.
	 */
	public void visitBranchDestination(int offset) {
	}

	/**
	 * Visit a jump instruction.
	 *
	 * @param opcode
	 * 		Jump instruction opcode.
	 * @param offset
	 * 		Absolute offset in the method code for the destination.
	 */
	public void visitJump(int opcode, int offset) {
	}

	/**
	 * Visit an {@code MULTIANEWARRAY} instruction.
	 *
	 * @param opcode
	 *        {@code MULTIANEWARRAY}
	 * @param type
	 * 		Object type.
	 * @param dimensions
	 * 		Number of dimentsions.
	 */
	public void visitMultiANewArray(int opcode, String type, int dimensions) {
	}

	/**
	 * Visit a load-constant instruction.
	 *
	 * @param opcode
	 *        {@code LDC}
	 * @param value
	 * 		Value to push.
	 */
	public void visitLdc(int opcode, Object value) {
	}

	/**
	 * Visit an integer increment instruction.
	 *
	 * @param opcode
	 *        {@code IINC}
	 * @param index
	 * 		Variable index to increment.
	 * @param incr
	 * 		Value to increment by.
	 */
	public void visitIinc(int opcode, int index, int incr) {
	}

	/**
	 * Visit a variable instruction.
	 *
	 * @param opcode
	 * 		Variable instruction opcode. It is not adjusted to conform to ASM
	 * 		<i>(Use {@link OpcodeUtil#deindexVarOp(int)} for that)</i>.
	 * @param index
	 * 		Index of the local variable.
	 */
	public void visitVar(int opcode, int index) {
	}

	/**
	 * Visit a method invocation instruction.
	 *
	 * @param opcode
	 * 		Method invocation opcode.
	 * @param owner
	 * 		Declaring type of method.
	 * @param name
	 * 		Method name.
	 * @param desc
	 * 		Method descriptor.
	 */
	public void visitMethod(int opcode, String owner, String name, String desc) {
	}

	/**
	 * Visit a field reference instruction.
	 *
	 * @param opcode
	 * 		Field reference opcode.
	 * @param owner
	 * 		Declaring type of field.
	 * @param name
	 * 		Field name.
	 * @param desc
	 * 		Field descriptor.
	 */
	public void visitField(int opcode, String owner, String name, String desc) {
	}

	/**
	 * Visit an integer push instruction.
	 *
	 * @param opcode
	 * 		Integer push opcode.
	 * @param value
	 * 		Value to push onto the stack.
	 */
	public void visitInt(int opcode, int value) {
	}

	/**
	 * Visit a type instruction.
	 *
	 * @param opcode
	 * 		Type opcode.
	 * @param type
	 * 		Type of the instruction.
	 */
	public void visitType(int opcode, String type) {
	}

	/**
	 * Visit a no-arg instruction.
	 *
	 * @param opcode
	 * 		Instruction opcode.
	 */
	public void visitInsn(int opcode) {
	}
}
